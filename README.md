# BlockChain-Learning
## SHA256

### 预处理

假设要计算的字符串的**二进制**长度为l，首先在串末尾加上1，再加上k位0，需要满足再补上64位就是512的倍数，即：
```
l + 1 + k === -64 mod 512
```
再补上64位的原字符串长度l的二进制表示

例如对于字符串`abc`，其二进制表示为`01100001 01100010 01100011`，长度为`l = 24`

计算得`k = 512 - 24 - 1 - 64 = 423`

`24`的64为二进制表示为`11000`

故对于`abc`而言，得到的结果为：
```go
01100001011000100110001110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011000
```
然后还需要对得到的字符串按照每512位进行分块，`abc`很短，就只有一块

预处理的步骤使用go写成如下
```go
func prepare(s []byte) [][]byte {
    // append a bytes started with bit '1'
    tmp := append(s, 0x80)
    l := len(s)
    // zero-padding
    if l % 64 < 56 {
        tmp = append(tmp, make([]byte, 55 - l % 64)...)
    } else {
        tmp = append(tmp, make([]byte, 121 - l % 64)...)
    }
    // raw data length
    tmp2 := make([]byte, 8)
    binary.BigEndian.PutUint64(tmp2, uint64(l<<3))
    tmp = append(tmp, tmp2...)
    // chunk
    var prepared [][]byte
    for i := 0; i < len(tmp) / 64; i++ {
        prepared = append(prepared, tmp[i * 64 : i * 64 + 64])
    }
    return prepared
}
```

### 计算
对每一块的计算过程如下(512位 64字节):

分割成若干小块，每小块是32位(4字节)。所以现在我们有16个小块。在后面补上48个为0的小块。一共有64个小块，用`w[0...63]`表示

后面就是计算，定义了若干常量，涉及大量位运算

这篇文章把计算步骤写得很清楚[https://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/](https://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/)

完整脚本在sha256.go
## Merkle Tree