# BlockChain-Learning
## SHA256

### 初始哈希值和常量

有计算过程中，需要用到8个哈希初值(自然数中前8个素数的平方根的小数部分前32位)和64个常数(自然数中前64个素数的立方根的小数部分前32位)。定义如下：
```go
initHash := [...]uint32{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19}
initConst := [...]uint32{0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174 ,0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da ,0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967 ,0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85 ,0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070 ,0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3 ,0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2}
```

### 预处理

假设要计算的字符串的**二进制**长度为l，首先在串末尾加上1，再加上k位0，需要满足再补上64位就是512的倍数，即：
```
l + 1 + k === -64 mod 512
```
再补上64位的原字符串长度l的二进制表示

例如对于字符串`abc`，其二进制表示为`01100001 01100010 01100011`，长度为`l = 24`

计算得`k = 512 - 24 - 1 - 64 = 423`

`24`的64为二进制表示为`11000`

故对于`abc`而言，得到的结果为：
```go
01100001011000100110001110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011000
```
然后还需要对得到的字符串按照每512位进行分块，`abc`很短，就只有一块

预处理的步骤使用go写成如下
```go
func prepare(s []byte) [][]byte {
    // append a bytes started with bit '1'
    tmp := append(s, 0x80)
    l := len(s)
    // zero-padding
    if l % 64 < 56 {
        tmp = append(tmp, make([]byte, 55 - l % 64)...)
    } else {
        tmp = append(tmp, make([]byte, 121 - l % 64)...)
    }
    // raw data length
    tmp2 := make([]byte, 8)
    binary.BigEndian.PutUint64(tmp2, uint64(l<<3))
    tmp = append(tmp, tmp2...)
    // chunk
    var prepared [][]byte
    for i := 0; i < len(tmp) / 64; i++ {
        prepared = append(prepared, tmp[i * 64 : i * 64 + 64])
    }
    return prepared
}
```

### 计算
对每一块的计算过程如下(512位 64字节):

分割成若干小块，每小块是32位(4字节)。所以现在我们有16个小块。在后面补上48个为0的小块。一共有64个小块，用`w[0...63]`表示




## Merkle Tree